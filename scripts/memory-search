#!/bin/bash
#
# Enhanced Memory Search Tool
# Search across all memory tiers with smart ranking
#

WORKSPACE_DIR="/root/.openclaw/workspace"
MEMORY_DIR="${WORKSPACE_DIR}/memory"

usage() {
    cat << EOF
Usage: memory-search [OPTIONS] <query>

Search across all memory tiers with intelligent ranking.

Options:
  -t, --tier TIER     Search only specific tier (active|working|archive|reference)
  -d, --days N        Search last N days only
  -p, --project NAME  Search within specific project
  -r, --rank          Rank results by relevance (smart search)
  -s, --summary       Show summary instead of full matches
  -l, --list          List all memory files by tier
  -h, --help          Show this help

Examples:
  memory-search 'kindred-ai'              # Search all tiers
  memory-search -t reference 'decision'   # Search reference only
  memory-search -d 30 -r 'security'       # Ranked search, last 30 days
  memory-search -p kindred-ai deploy      # Project-specific search
  memory-search -l                        # List all memory files

EOF
}

# List all memory files organized by tier
list_all() {
    echo "=== MEMORY ARCHITECTURE ==="
    echo ""
    
    echo "ðŸ“ ACTIVE (last 7 days):"
    find "${MEMORY_DIR}" -maxdepth 1 -name "[0-9]*-[0-9]*-[0-9]*.md" -type f 2>/dev/null | sort -r | while read f; do
        local date=$(basename "$f" .md)
        local size=$(wc -l < "$f" | tr -d ' ')
        echo "  $date ($size lines)"
    done
    
    echo ""
    echo "ðŸ“ WORKING (last 30 days):"
    find "${MEMORY_DIR}/working" -name "*.md" -type f 2>/dev/null | sort -r | head -10 | while read f; do
        echo "  $(basename $f)"
    done
    local working_count=$(find "${MEMORY_DIR}/working" -name "*.md" 2>/dev/null | wc -l)
    [ "$working_count" -gt 10 ] && echo "  ... and $((working_count - 10)) more"
    
    echo ""
    echo "ðŸ“¦ ARCHIVE (long-term):"
    local archive_daily=$(find "${MEMORY_DIR}/archive/daily" -name "*.md" 2>/dev/null | wc -l)
    local archive_bundles=$(find "${MEMORY_DIR}/archive/bundles" -name "*.gz" 2>/dev/null | wc -l)
    echo "  Daily files: $archive_daily"
    echo "  Compressed bundles: $archive_bundles"
    
    echo ""
    echo "ðŸ“š REFERENCE (permanent):"
    find "${MEMORY_DIR}/reference" -type d -mindepth 1 -maxdepth 1 2>/dev/null | while read d; do
        local count=$(find "$d" -name "*.md" | wc -l)
        echo "  $(basename $d)/: $count files"
    done
    
    echo ""
    echo "ðŸ“Š TOTALS:"
    local total=$(find "${MEMORY_DIR}" -name "*.md" 2>/dev/null | wc -l)
    echo "  Total markdown files: $total"
}

# Calculate relevance score for a file
score_relevance() {
    local file="$1"
    local query="$2"
    local score=0
    
    # Title match (high weight)
    if echo "$(basename "$file")" | grep -qi "$query"; then
        score=$((score + 100))
    fi
    
    # Header match (medium weight)
    if grep -q "^#.*$query" "$file" 2>/dev/null; then
        score=$((score + 50))
    fi
    
    # Tag match (high weight)
    if grep -q "\[$query\]" "$file" 2>/dev/null; then
        score=$((score + 75))
    fi
    
    # Content frequency (low weight per match)
    local matches=$(grep -i -c "$query" "$file" 2>/dev/null || echo 0)
    score=$((score + matches * 5))
    
    # Recency bonus (if filename contains date)
    local filename=$(basename "$file")
    if [[ "$filename" =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
        local file_date="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
        local days_old=$(( ( $(date +%s) - $(date -d "$file_date" +%s 2>/dev/null || echo 0) ) / 86400 ))
        if [ "$days_old" -lt 30 ]; then
            score=$((score + 25))
        elif [ "$days_old" -lt 90 ]; then
            score=$((score + 10))
        fi
    fi
    
    echo "$score"
}

# Smart ranked search
search_ranked() {
    local query="$1"
    local days="$2"
    
    echo "ðŸ” SMART SEARCH: '$query'"
    echo ""
    
    local results_file=$(mktemp)
    
    # Search all tiers and score
    {
        # Active
        find "${MEMORY_DIR}" -maxdepth 1 -name "*.md" -type f 2>/dev/null
        
        # Working
        find "${MEMORY_DIR}/working" -name "*.md" -type f 2>/dev/null
        
        # Archive (respect days limit)
        if [ -n "$days" ]; then
            find "${MEMORY_DIR}/archive/daily" -name "*.md" -mtime -$days 2>/dev/null
        fi
        
        # Reference
        find "${MEMORY_DIR}/reference" -name "*.md" -type f 2>/dev/null
    } | while read file; do
        if grep -qi "$query" "$file" 2>/dev/null; then
            local score=$(score_relevance "$file" "$query")
            local tier=$(get_tier "$file")
            echo "$score|$tier|$file"
        fi
    done | sort -t'|' -k1 -nr > "$results_file"
    
    # Display top results
    local count=0
    while IFS='|' read -r score tier file; do
        [ -z "$file" ] && continue
        count=$((count + 1))
        [ $count -gt 10 ] && break
        
        local filename=$(basename "$file")
        echo "[$tier | score:$score] $filename"
        
        # Show matching context
        grep -i -n -B1 -A1 "$query" "$file" 2>/dev/null | head -6 | sed 's/^/  /'
        echo ""
    done < "$results_file"
    
    local total=$(wc -l < "$results_file" | tr -d ' ')
    echo "Found $total matches (showing top 10)"
    
    rm -f "$results_file"
}

# Get tier name for a file
get_tier() {
    local file="$1"
    case "$file" in
        *reference*) echo "REF" ;;
        *archive*) echo "ARC" ;;
        *working*) echo "WRK" ;;
        *) echo "ACT" ;;
    esac
}

# Simple grep search for a tier
search_tier() {
    local tier=$1
    local query=$2
    local path
    
    case $tier in
        active) path="${MEMORY_DIR}" ;;
        working) path="${MEMORY_DIR}/working" ;;
        archive) path="${MEMORY_DIR}/archive" ;;
        reference) path="${MEMORY_DIR}/reference" ;;
        *) echo "Unknown tier: $tier"; exit 1 ;;
    esac
    
    echo "=== $tier ==="
    
    if [ -d "$path" ]; then
        grep -r -i -n --include="*.md" -l "$query" "$path" 2>/dev/null | head -10 | while read f; do
            echo "  $(basename $f)"
            grep -i -n "$query" "$f" 2>/dev/null | head -3 | sed 's/^/    /'
        done
    fi
}

# Search archive bundles (compressed files)
search_archive_bundles() {
    local query="$1"
    local year="$2"
    
    echo "=== ARCHIVE BUNDLES ==="
    
    local bundle_dir="${MEMORY_DIR}/archive/bundles"
    [ -n "$year" ] && bundle_dir="$bundle_dir/$year"
    
    if [ -d "$bundle_dir" ]; then
        find "$bundle_dir" -name "*.gz" -type f 2>/dev/null | while read f; do
            if zgrep -q -i "$query" "$f" 2>/dev/null; then
                echo "  $(basename $f) (compressed)"
                zgrep -i -n "$query" "$f" 2>/dev/null | head -2 | sed 's/^/    /'
            fi
        done
    fi
}

# Parse arguments
TIER=""
DAYS=""
PROJECT=""
RANK=false
SUMMARY=false
QUERY=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--tier)
            TIER="$2"
            shift 2
            ;;
        -d|--days)
            DAYS="$2"
            shift 2
            ;;
        -p|--project)
            PROJECT="$2"
            shift 2
            ;;
        -r|--rank)
            RANK=true
            shift
            ;;
        -s|--summary)
            SUMMARY=true
            shift
            ;;
        -l|--list)
            list_all
            exit 0
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            QUERY="$1"
            shift
            ;;
    esac
done

if [ -z "$QUERY" ]; then
    usage
    exit 1
fi

# Build effective query
if [ -n "$PROJECT" ]; then
    QUERY="$QUERY.*\[project:$PROJECT\]|\[project:$PROJECT\].*$QUERY"
fi

# Execute search
if [ "$RANK" = true ]; then
    search_ranked "$QUERY" "$DAYS"
else
    if [ -n "$TIER" ]; then
        search_tier "$TIER" "$QUERY"
    else
        search_tier "active" "$QUERY"
        echo ""
        search_tier "working" "$QUERY"
        echo ""
        search_tier "reference" "$QUERY"
        echo ""
        search_archive_bundles "$QUERY"
    fi
fi
