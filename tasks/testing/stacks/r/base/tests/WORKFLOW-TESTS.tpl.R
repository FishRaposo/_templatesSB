# -----------------------------------------------------------------------------
# FILE: workflow-tests.tpl.R
# PURPOSE: Comprehensive workflow test suite for R package development and CI/CD
# USAGE: Copy to tests/testthat/ directory and extend for specific projects
# AUTHOR: {{AUTHOR}}
# VERSION: {{VERSION}}
# SINCE: {{VERSION}}
# -----------------------------------------------------------------------------

"""
{{PROJECT_NAME}} - Workflow Test Suite
Comprehensive workflow tests for package building, CI/CD, documentation, and deployment.

Author: {{AUTHOR}}
Created: {{DATE}}
"""

# Load required libraries
library(testthat)
library(devtools)
library(usethis)
library(pkgdown)
library(rcmdcheck)
library(roxygen2)
library(git2r)
library(withr)
library(callr)

# Setup test environment
context("Workflow Tests - {{PROJECT_NAME}}")

# -----------------------------------------------------------------------------
# PACKAGE BUILDING AND VALIDATION TESTS
# -----------------------------------------------------------------------------

test_that("Package structure follows R package standards", {
  # Create temporary package directory
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create minimal package structure
  create_test_package <- function(pkg_path) {
    # Create DESCRIPTION file
    description_content <- paste(
      "Package: {{PROJECT_NAME}}",
      "Title: Test Package for Workflow Validation",
      "Version: 0.1.0",
      "Authors@R: person('Test', 'Author', email = 'test@example.com', role = c('aut', 'cre'))",
      "Description: A test package for validating R package workflows.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      sep = "\n"
    )
    writeLines(description_content, file.path(pkg_path, "DESCRIPTION"))
    
    # Create NAMESPACE file
    writeLines("# Generated by roxygen2: do not edit by hand", file.path(pkg_path, "NAMESPACE"))
    
    # Create R directory and sample function
    dir.create(file.path(pkg_path, "R"))
    
    r_content <- '
      #' Test function for package validation
      #'
      #' @param x A numeric vector
      #' @param y A numeric vector
      #' @return A numeric result
      #' @examples
      #' test_function(c(1, 2, 3), c(4, 5, 6))
      #' @export
      test_function <- function(x, y) {
        if (length(x) != length(y)) {
          stop("x and y must have the same length")
        }
        return(x + y)
      }
      
      #' Data processing function
      #'
      #' @param df A data frame
      #' @param threshold A numeric threshold value
      #' @return A processed data frame
      #' @export
      process_data <- function(df, threshold = 0.5) {
        if (!is.data.frame(df)) {
          stop("Input must be a data frame")
        }
        return(df[df$value > threshold, ])
      }
    '
    writeLines(r_content, file.path(pkg_path, "R", "functions.R"))
    
    # Create tests directory
    dir.create(file.path(pkg_path, "tests"))
    dir.create(file.path(pkg_path, "tests", "testthat"))
    
    test_content <- '
      test_that("test_function works correctly", {
        result <- test_function(1:3, 4:6)
        expect_equal(result, c(5, 7, 9))
      })
      
      test_that("process_data filters correctly", {
        test_df <- data.frame(value = c(0.3, 0.7, 0.9))
        result <- process_data(test_df, threshold = 0.5)
        expect_equal(nrow(result), 2)
      })
    '
    writeLines(test_content, file.path(pkg_path, "tests", "testthat", "test-functions.R"))
    
    # Create test runner
    test_runner <- 'library(testthat)
      library({{PROJECT_NAME}})
      test_check("{{PROJECT_NAME}}")'
    writeLines(test_runner, file.path(pkg_path, "tests", "testthat.R"))
    
    return(pkg_path)
  }
  
  pkg_path <- create_test_package(temp_pkg)
  
  # Validate package structure
  expect_true(file.exists(file.path(pkg_path, "DESCRIPTION")))
  expect_true(file.exists(file.path(pkg_path, "NAMESPACE")))
  expect_true(dir.exists(file.path(pkg_path, "R")))
  expect_true(dir.exists(file.path(pkg_path, "tests")))
  expect_true(dir.exists(file.path(pkg_path, "tests", "testthat")))
  
  # Check DESCRIPTION file
  desc <- readLines(file.path(pkg_path, "DESCRIPTION"))
  expect_true(any(grepl("Package:", desc)))
  expect_true(any(grepl("Version:", desc)))
  expect_true(any(grepl("Title:", desc)))
  expect_true(any(grepl("Description:", desc)))
  expect_true(any(grepl("License:", desc)))
  
  # Validate R files
  r_files <- list.files(file.path(pkg_path, "R"), pattern = "\\.R$")
  expect_true(length(r_files) > 0)
  
  # Test package loading
  expect_true(requireNamespace("tools", quietly = TRUE))
  
  # Run basic package checks
  check_results <- tools::checkPkgBuild(pkg_path)
  expect_is(check_results, "list")
})

test_that("Package documentation generates correctly", {
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create package with roxygen2 documentation
  create_doc_package <- function(pkg_path) {
    # DESCRIPTION
    desc_content <- paste(
      "Package: DocTestPkg",
      "Title: Documentation Test Package",
      "Version: 0.1.0",
      "Authors@R: person('Doc', 'Author', email = 'doc@example.com', role = c('aut', 'cre'))",
      "Description: Test package for documentation workflows.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # R directory
    dir.create(file.path(pkg_path, "R"))
    
    # Function with documentation
    func_content <- '
      #' Calculate summary statistics
      #'
      #' This function calculates various summary statistics for a numeric vector.
      #'
      #' @param x A numeric vector
      #' @param na.rm Logical, whether to remove NA values
      #' @return A list containing summary statistics
      #' @examples
      #' \dontrun{
      #' calculate_stats(c(1, 2, 3, 4, 5))
      #' }
      #' @export
      calculate_stats <- function(x, na.rm = TRUE) {
        if (!is.numeric(x)) {
          stop("Input must be numeric")
        }
        
        list(
          mean = mean(x, na.rm = na.rm),
          median = median(x, na.rm = na.rm),
          sd = sd(x, na.rm = na.rm),
          min = min(x, na.rm = na.rm),
          max = max(x, na.rm = na.rm),
          n = length(x),
          n_missing = sum(is.na(x))
        )
      }
      
      #' Data processing pipeline
      #'
      #' @param df Input data frame
      #' @param config Processing configuration list
      #' @return Processed data frame
      #' @export
      process_pipeline <- function(df, config = list()) {
        defaults <- list(
          remove_outliers = TRUE,
          normalize = FALSE,
          missing_threshold = 0.1
        )
        
        config <- modifyList(defaults, config)
        
        df %>%
          tidyr::drop_na() %>%
          {
            if (config$remove_outliers) {
              . %>% filter(value < quantile(value, 0.99) & value > quantile(value, 0.01))
            } else {
              .
            }
          } %>%
          {
            if (config$normalize) {
              . %>% mutate(value = scale(value))
            } else {
              .
            }
          }
      }
    '
    writeLines(func_content, file.path(pkg_path, "R", "stats.R"))
    
    # Create man directory
    dir.create(file.path(pkg_path, "man"))
    
    return(pkg_path)
  }
  
  pkg_path <- create_doc_package(temp_pkg)
  
  # Generate documentation
  if (requireNamespace("roxygen2", quietly = TRUE)) {
    roxygen2::roxygenise(pkg_path)
    
    # Check if documentation files were created
    man_files <- list.files(file.path(pkg_path, "man"), pattern = "\\.Rd$")
    expect_true(length(man_files) >= 2)  # Should have documentation for both functions
    
    # Check NAMESPACE was updated
    namespace_content <- readLines(file.path(pkg_path, "NAMESPACE"))
    expect_true(any(grepl("export", namespace_content)))
  }
})

test_that("Package passes R CMD check", {
  skip_on_cran()
  skip_if_not_installed("rcmdcheck")
  
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create a clean package that should pass checks
  create_clean_package <- function(pkg_path) {
    # DESCRIPTION
    desc_content <- paste(
      "Package: CleanPkg",
      "Title: Clean Package for Testing",
      "Version: 0.1.0",
      "Authors@R: person('Clean', 'Author', email = 'clean@example.com', role = c('aut', 'cre'))",
      "Description: A clean package that should pass R CMD check.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # LICENSE file
    writeLines("MIT License", file.path(pkg_path, "LICENSE"))
    
    # R directory
    dir.create(file.path(pkg_path, "R"))
    
    # Clean function
    clean_func <- '
      #' Add two numbers
      #'
      #' @param x First number
      #' @param y Second number
      #' @return Sum of x and y
      #' @examples
      #' add_numbers(1, 2)
      #' @export
      add_numbers <- function(x, y) {
        if (!is.numeric(x) || !is.numeric(y)) {
          stop("Both arguments must be numeric")
        }
        return(x + y)
      }
    '
    writeLines(clean_func, file.path(pkg_path, "R", "add.R"))
    
    # Tests
    dir.create(file.path(pkg_path, "tests"))
    dir.create(file.path(pkg_path, "tests", "testthat"))
    
    test_content <- '
      test_that("add_numbers works correctly", {
        expect_equal(add_numbers(1, 2), 3)
        expect_equal(add_numbers(0, 0), 0)
        expect_equal(add_numbers(-1, 1), 0)
        expect_error(add_numbers("a", 1))
      })
    '
    writeLines(test_content, file.path(pkg_path, "tests", "testthat", "test-add.R"))
    
    test_runner <- 'library(testthat)
      library(CleanPkg)
      test_check("CleanPkg")'
    writeLines(test_runner, file.path(pkg_path, "tests", "testthat.R"))
    
    # Generate documentation
    if (requireNamespace("roxygen2", quietly = TRUE)) {
      roxygen2::roxygenise(pkg_path)
    }
    
    return(pkg_path)
  }
  
  pkg_path <- create_clean_package(temp_pkg)
  
  # Run R CMD check
  check_results <- rcmdcheck::rcmdcheck(
    pkg_path,
    args = c("--no-manual", "--no-vignettes"),
    error_on = "never"
  )
  
  # Check results
  expect_is(check_results, "rcmdcheck")
  expect_equal(check_results$errors, 0)  # No errors
  expect_equal(check_results$warnings, 0)  # No warnings for clean package
})

# -----------------------------------------------------------------------------
# CI/CD INTEGRATION TESTS
# -----------------------------------------------------------------------------

test_that("GitHub Actions workflow files are valid", {
  temp_dir <- tempfile()
  dir.create(temp_dir)
  on.exit(unlink(temp_dir, recursive = TRUE), add = TRUE)
  
  # Create GitHub Actions workflow
  create_github_workflow <- function(workflow_dir) {
    # Create .github/workflows directory
    workflows_dir <- file.path(workflow_dir, ".github", "workflows")
    dir.create(file.path(workflow_dir, ".github"), recursive = TRUE)
    dir.create(workflows_dir, recursive = TRUE)
    
    # R CMD check workflow
    r_cmd_check <- '
      name: R-CMD-check
      
      on:
        push:
          branches: [main, master]
        pull_request:
          branches: [main, master]
      
      jobs:
        R-CMD-check:
          runs-on: ${{ matrix.config.os }}
          
          name: ${{ matrix.config.os }} (${{ matrix.config.r }})
          
          strategy:
            matrix:
              config:
                - {os: ubuntu-latest, r: "release"}
                - {os: windows-latest, r: "release"}
                - {os: macOS-latest, r: "release"}
          
          steps:
            - uses: actions/checkout@v3
            
            - uses: r-lib/actions/setup-r@v2
              with:
                r-version: ${{ matrix.config.r }}
                use-public-rspm: true
            
            - uses: r-lib/actions/setup-r-dependencies@v2
              with:
                extra-packages: any::rcmdcheck
                needs: check
            
            - uses: r-lib/actions/check-r-package@v2
              with:
                upload-snapshots: true
    '
    writeLines(r_cmd_check, file.path(workflows_dir, "R-CMD-check.yaml"))
    
    # Test coverage workflow
    test_coverage <- '
      name: test-coverage
      
      on:
        push:
          branches: [main, master]
        pull_request:
          branches: [main, master]
      
      jobs:
        test-coverage:
          runs-on: ubuntu-latest
          
          steps:
            - uses: actions/checkout@v3
            
            - uses: r-lib/actions/setup-r@v2
              with:
                use-public-rspm: true
            
            - uses: r-lib/actions/setup-r-dependencies@v2
              with:
                extra-packages: any::covr
                needs: coverage
            
            - name: Test coverage
              run: covr::codecov()
              shell: Rscript {0}
    '
    writeLines(test_coverage, file.path(workflows_dir, "test-coverage.yaml"))
    
    return(workflows_dir)
  }
  
  workflows_dir <- create_github_workflow(temp_dir)
  
  # Validate workflow files
  workflow_files <- list.files(workflows_dir, pattern = "\\.yaml$")
  expect_true(length(workflow_files) >= 2)
  
  # Check YAML syntax (basic validation)
  for (file in workflow_files) {
    content <- readLines(file.path(workflows_dir, file))
    expect_true(length(content) > 0)
    expect_true(any(grepl("name:", content)))
    expect_true(any(grepl("on:", content)))
    expect_true(any(grepl("jobs:", content)))
  }
})

test_that("Docker containerization works correctly", {
  temp_dir <- tempfile()
  dir.create(temp_dir)
  on.exit(unlink(temp_dir, recursive = TRUE), add = TRUE)
  
  # Create Dockerfile for R package
  dockerfile_content <- '
    FROM rocker/r-ver:4.3.0
    
    # Install system dependencies
    RUN apt-get update && apt-get install -y \\
      git \\
      libcurl4-openssl-dev \\
      libssl-dev \\
      libxml2-dev \\
      && rm -rf /var/lib/apt/lists/*
    
    # Install R packages
    RUN install2.r --error \\
      remotes \\
      devtools \\
      testthat \\
      roxygen2
    
    # Set working directory
    WORKDIR /app
    
    # Copy package files
    COPY . /app
    
    # Install package dependencies
    RUN R -e "remotes::install_deps(dependencies = TRUE)"
    
    # Install the package
    RUN R CMD INSTALL .
    
    # Run tests
    CMD ["R", "-e", "devtools::test()"]
  '
  writeLines(dockerfile_content, file.path(temp_dir, "Dockerfile"))
  
  # Create .dockerignore
  dockerignore_content <- '
    .git
    .Rhistory
    .RData
    .Rproj.user
    inst/doc
    doc
    Meta
  '
  writeLines(dockerignore_content, file.path(temp_dir, ".dockerignore"))
  
  # Validate Docker files
  expect_true(file.exists(file.path(temp_dir, "Dockerfile")))
  expect_true(file.exists(file.path(temp_dir, ".dockerignore")))
  
  # Check Dockerfile content
  dockerfile_lines <- readLines(file.path(temp_dir, "Dockerfile"))
  expect_true(any(grepl("FROM", dockerfile_lines)))
  expect_true(any(grepl("RUN", dockerfile_lines)))
  expect_true(any(grepl("COPY", dockerfile_lines)))
  expect_true(any(grepl("CMD", dockerfile_lines)))
})

# -----------------------------------------------------------------------------
# DOCUMENTATION GENERATION TESTS
# -----------------------------------------------------------------------------

test_that("pkgdown documentation generates successfully", {
  skip_if_not_installed("pkgdown")
  
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create package suitable for pkgdown
  create_pkgdown_package <- function(pkg_path) {
    # DESCRIPTION
    desc_content <- paste(
      "Package: PkgdownTest",
      "Title: Package for pkgdown Testing",
      "Version: 0.1.0",
      "Authors@R: person('Pkgdown', 'Author', email = 'pkgdown@example.com', role = c('aut', 'cre'))",
      "Description: Test package for pkgdown documentation generation.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      "URL: https://github.com/test/testpkg",
      "BugReports: https://github.com/test/testpkg/issues",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # LICENSE
    writeLines("MIT License", file.path(pkg_path, "LICENSE"))
    
    # R directory
    dir.create(file.path(pkg_path, "R"))
    
    # Documented functions
    func_content <- '
      #' Test function for documentation
      #'
      #' This function demonstrates pkgdown documentation generation.
      #'
      #' @param x A numeric vector
      #' @param multiplier A multiplier value
      #' @return Multiplied vector
      #' @examples
      #' multiply_vector(c(1, 2, 3), 2)
      #' @export
      multiply_vector <- function(x, multiplier = 1) {
        x * multiplier
      }
      
      #' Data analysis function
      #'
      #' @param df Input data frame
      #' @param column Column to analyze
      #' @return Analysis results
      #' @export
      analyze_data <- function(df, column) {
        list(
          mean = mean(df[[column]], na.rm = TRUE),
          sd = sd(df[[column]], na.rm = TRUE),
          n = sum(!is.na(df[[column]]))
        )
      }
    '
    writeLines(func_content, file.path(pkg_path, "R", "functions.R"))
    
    # Generate documentation
    if (requireNamespace("roxygen2", quietly = TRUE)) {
      roxygen2::roxygenise(pkg_path)
    }
    
    # Create README
    readme_content <- '
      # PkgdownTest
      
      <!-- badges: start -->
      [![R-CMD-check](https://github.com/test/testpkg/workflows/R-CMD-check/badge.svg)](https://github.com/test/testpkg/actions)
      <!-- badges: end -->
      
      Test package for pkgdown documentation generation.
      
      ## Installation
      
      You can install the development version of PkgdownTest from [GitHub](https://github.com/) with:
      
      ``` r
      # install.packages("devtools")
      devtools::install_github("test/testpkg")
      ```
      
      ## Example
      
      This is a basic example which shows you how to solve a common problem:
      
      ``` r
      library(PkgdownTest)
      multiply_vector(c(1, 2, 3), 2)
      ```
    '
    writeLines(readme_content, file.path(pkg_path, "README.md"))
    
    # Create _pkgdown.yml
    pkgdown_config <- '
      url: https://test.github.io/testpkg/
      
      template:
        bootstrap: 5
        
      development:
        mode: auto
        
      reference:
        - title: "Utility Functions"
          desc: "Basic utility functions"
          contents:
            - multiply_vector
        - title: "Analysis Functions"
          desc: "Data analysis functions"
          contents:
            - analyze_data
    '
    writeLines(pkgdown_config, file.path(pkg_path, "_pkgdown.yml"))
    
    return(pkg_path)
  }
  
  pkg_path <- create_pkgdown_package(temp_pkg)
  
  # Build pkgdown site
  withr::with_dir(pkg_path, {
    pkgdown::build_site(override = list(
      destination = file.path(pkg_path, "docs")
    ))
  })
  
  # Check if documentation was generated
  docs_dir <- file.path(pkg_path, "docs")
  expect_true(dir.exists(docs_dir))
  
  # Check for key files
  expect_true(file.exists(file.path(docs_dir, "index.html")))
  expect_true(file.exists(file.path(docs_dir, "reference", "index.html")))
  expect_true(dir.exists(file.path(docs_dir, "reference")))
})

test_that("Vignettes build and render correctly", {
  skip_if_not_installed("rmarkdown")
  
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create package with vignettes
  create_vignette_package <- function(pkg_path) {
    # DESCRIPTION
    desc_content <- paste(
      "Package: VignetteTest",
      "Title: Package for Vignette Testing",
      "Version: 0.1.0",
      "Authors@R: person('Vignette', 'Author', email = 'vignette@example.com', role = c('aut', 'cre'))",
      "Description: Test package for vignette building.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      "VignetteBuilder: knitr",
      "Suggests: knitr, rmarkdown",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # Create vignettes directory
    vignettes_dir <- file.path(pkg_path, "vignettes")
    dir.create(vignettes_dir)
    
    # Create vignette
    vignette_content <- '
      ---
      title: "Getting Started with VignetteTest"
      output: rmarkdown::html_vignette
      vignette: >
        %\\VignetteIndexEntry{Getting Started with VignetteTest}
        %\\VignetteEngine{knitr::rmarkdown}
        %\\VignetteEncoding{UTF-8}
      ---
      
      ```{r, include = FALSE}
      knitr::opts_chunk$set(
        collapse = TRUE,
        comment = "#>"
      )
      ```
      
      ## Introduction
      
      This vignette demonstrates how to use the VignetteTest package.
      
      ## Basic Usage
      
      First, load the package:
      
      ```{r setup}
      library(VignetteTest)
      ```
      
      ## Example Analysis
      
      Here is a simple example:
      
      ```{r example}
      # Create sample data
data <- data.frame(
        x = 1:100,
        y = rnorm(100, mean = 50, sd = 10)
      )
      
      # Basic analysis
      summary(data)
      ```
      
      ## Conclusion
      
      This vignette shows the basic functionality of the package.
    '
    writeLines(vignette_content, file.path(vignettes_dir, "getting-started.Rmd"))
    
    return pkg_path
  }
  
  pkg_path <- create_vignette_package(temp_pkg)
  
  # Check vignette structure
  vignettes_dir <- file.path(pkg_path, "vignettes")
  expect_true(dir.exists(vignettes_dir))
  
  vignette_files <- list.files(vignettes_dir, pattern = "\\.Rmd$")
  expect_true(length(vignette_files) > 0)
  
  # Validate vignette YAML header
  vignette_content <- readLines(file.path(vignettes_dir, "getting-started.Rmd"))
  expect_true(any(grepl("VignetteIndexEntry", vignette_content)))
  expect_true(any(grepl("VignetteEngine", vignette_content)))
  expect_true(any(grepl("VignetteEncoding", vignette_content)))
})

# -----------------------------------------------------------------------------
# DEPLOYMENT AND DISTRIBUTION TESTS
# -----------------------------------------------------------------------------

test_that("Package can be built and installed", {
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create installable package
  installable_pkg <- function(pkg_path) {
    # DESCRIPTION
    desc_content <- paste(
      "Package: InstallTest",
      "Title: Package for Installation Testing",
      "Version: 0.1.0",
      "Authors@R: person('Install', 'Author', email = 'install@example.com', role = c('aut', 'cre'))",
      "Description: Test package for installation workflows.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # LICENSE
    writeLines("MIT License", file.path(pkg_path, "LICENSE"))
    
    # R directory
    dir.create(file.path(pkg_path, "R"))
    
    # Simple function
    simple_func <- '
      #' Simple test function
      #'
      #' @param x Input value
      #' @return Processed value
      #' @export
      simple_test <- function(x) {
        x * 2
      }
    '
    writeLines(simple_func, file.path(pkg_path, "R", "simple.R"))
    
    # Generate documentation
    if (requireNamespace("roxygen2", quietly = TRUE)) {
      roxygen2::roxygenise(pkg_path)
    }
    
    return(pkg_path)
  }
  
  pkg_path <- installable_pkg(temp_pkg)
  
  # Build package
  built_path <- devtools::build(pkg_path)
  expect_true(file.exists(built_path))
  expect_true(grepl("\\.tar\\.gz$", built_path))
  
  # Test installation in isolated environment
  temp_lib <- tempfile()
  dir.create(temp_lib)
  on.exit(unlink(temp_lib, recursive = TRUE), add = TRUE)
  
  # Install package
  install_result <- tryCatch({
    install.packages(built_path, lib = temp_lib, repos = NULL, type = "source")
    TRUE
  }, error = function(e) {
    FALSE
  })
  
  expect_true(install_result)
  
  # Test loading
  if (install_result) {
    load_result <- tryCatch({
      library(InstallTest, lib.loc = temp_lib)
      simple_test(5)
    }, error = function(e) {
      NULL
    })
    
    expect_equal(load_result, 10)
  }
})

test_that("CRAN submission requirements are met", {
  temp_pkg <- tempfile()
  dir.create(temp_pkg)
  on.exit(unlink(temp_pkg, recursive = TRUE), add = TRUE)
  
  # Create CRAN-ready package
  cran_package <- function(pkg_path) {
    # DESCRIPTION with all required fields
    desc_content <- paste(
      "Package: CRANTest",
      "Type: Package",
      "Title: Package for CRAN Submission Testing",
      "Version: 0.1.0",
      "Date: 2023-12-01",
      "Authors@R: c(",
      "    person('CRAN', 'Author', email = 'cran@example.com', role = c('aut', 'cre'), comment = c(ORCID = '0000-0000-0000-0000'))",
      ")",
      "Maintainer: CRAN Author <cran@example.com>",
      "Description: A comprehensive test package that meets all CRAN submission requirements.",
      "   This package includes proper documentation, examples, tests, and follows all CRAN policies.",
      "License: MIT + file LICENSE",
      "Encoding: UTF-8",
      "RoxygenNote: 7.2.0",
      "NeedsCompilation: no",
      "Packaged: 2023-12-01 12:00:00 UTC; testuser",
      "Author: CRAN Author [aut, cre] (<https://orcid.org/0000-0000-0000-0000>)",
      sep = "\n"
    )
    writeLines(desc_content, file.path(pkg_path, "DESCRIPTION"))
    
    # LICENSE file
    license_content <- paste(
      "MIT License",
      "",
      "Copyright (c) 2023 CRAN Test",
      "",
      "Permission is hereby granted, free of charge, to any person obtaining a copy",
      "of this software and associated documentation files (the \"Software\"), to deal",
      "in the Software without restriction, including without limitation the rights",
      "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
      "copies of the Software, and to permit persons to whom the Software is",
      "furnished to do so, subject to the following conditions:",
      "",
      "The above copyright notice and this permission notice shall be included in all",
      "copies or substantial portions of the Software.",
      "",
      "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
      "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
      "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
      "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
      "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
      "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
      "SOFTWARE."
    )
    writeLines(license_content, file.path(pkg_path, "LICENSE"))
    
    # NEWS.md
    news_content <- '
      # CRANTest 0.1.0
      
      ## Initial release
      
      * Added core functionality for testing CRAN submission
      * Implemented comprehensive test suite
      * Added documentation and examples
      * Created vignettes for user guidance
    '
    writeLines(news_content, file.path(pkg_path, "NEWS.md"))
    
    # README.md
    readme_content <- '
      # CRANTest
      
      <!-- badges: start -->
      [![R-CMD-check](https://github.com/testuser/CRANTest/workflows/R-CMD-check/badge.svg)](https://github.com/testuser/CRANTest/actions)
      <!-- badges: end -->
      
      A comprehensive test package for CRAN submission requirements.
      
      ## Installation
      
      You can install the development version of CRANTest from [GitHub](https://github.com/) with:
      
      ``` r
      # install.packages("devtools")
      devtools::install_github("testuser/CRANTest")
      ```
      
      ## Example
      
      This is a basic example which shows you how to solve a common problem:
      
      ``` r
      library(CRANTest)
      ## basic example code
      ```
    '
    writeLines(readme_content, file.path(pkg_path, "README.md"))
    
    # R directory
    dir.create(file.path(pkg_path, "R"))
    
    # Main function
    main_func <- '
      # CRANTest: A comprehensive test package for CRAN submission requirements
      
      ""'
      CRANTest: Comprehensive Test Package for CRAN Submission
      
      A comprehensive test package that demonstrates all CRAN submission requirements
      including proper documentation, examples, tests, and policy compliance.
      ""'
      
      # Main function for CRANTest
      # This function demonstrates proper documentation and examples
      
      #' Test CRAN submission function
      #'
      #' This function tests various aspects of CRAN submission requirements.
      #'
      #' @param x A numeric vector for testing
      #' @param method Character string specifying the method to use
      #' @param verbose Logical indicating whether to print verbose output
      #' @return A list containing test results
      #' @details
      #' This function demonstrates proper documentation format for CRAN submission.
      #' It includes comprehensive parameter descriptions, return value documentation,
      #' and detailed explanation of the function\'s purpose and usage.
      #'
      #' @section Important Notes:
      #' \itemize{
      #'   \item The input vector \code{x} should contain numeric values.
      #'   \item The \code{method} parameter controls the analysis approach.
      #'   \item Set \code{verbose = TRUE} for detailed output.
      #' }
      #'
      #' @references
      #' \url{https://cran.r-project.org/doc/manuals/r-release/R-exts.html}
      #'
      #' @seealso
      #' \code{\link{summary}} for summary statistics
      #'
      #' @examples
      #' # Basic usage
      #' result <- test_cran_function(1:10)
      #' print(result$mean)
      #'
      #' # With custom method
      #' result <- test_cran_function(1:10, method = "advanced")
      #'
      #' # With verbose output
      #' result <- test_cran_function(rnorm(100), verbose = TRUE)
      #'
      #' @export
      test_cran_function <- function(x, method = c("basic", "advanced"), verbose = FALSE) {
        # Input validation
        if (!is.numeric(x)) {
          stop("Input x must be numeric")
        }
        
        if (length(x) == 0) {
          stop("Input x cannot be empty")
        }
        
        method <- match.arg(method)
        
        # Calculate statistics
        stats <- list(
          n = length(x),
          mean = mean(x),
          median = median(x),
          sd = sd(x),
          min = min(x),
          max = max(x),
          method = method
        )
        
        if (verbose) {
          message("Calculating statistics using method: ", method)
          message("Sample size: ", stats$n)
        }
        
        # Additional processing for advanced method
        if (method == "advanced") {
          stats$skewness <- sum((x - stats$mean)^3) / (length(x) * stats$sd^3)
          stats$kurtosis <- sum((x - stats$mean)^4) / (length(x) * stats$sd^4) - 3
        }
        
        return(stats)
      }
    '
    writeLines(main_func, file.path(pkg_path, "R", "main.R"))
    
    return(pkg_path)
  }
  
  pkg_path <- cran_package(temp_pkg)
  
  # Validate CRAN requirements
  
  # 1. Check DESCRIPTION fields
  desc_lines <- readLines(file.path(pkg_path, "DESCRIPTION"))
  required_fields <- c("Package:", "Type:", "Title:", "Version:", "Date:", 
                      "Authors@R:", "Maintainer:", "Description:", "License:", 
                      "Encoding:", "RoxygenNote:", "NeedsCompilation:", 
                      "Packaged:", "Author:")
  
  for (field in required_fields) {
    expect_true(any(grepl(field, desc_lines)), info = paste("Missing field:", field))
  }
  
  # 2. Check LICENSE file
  expect_true(file.exists(file.path(pkg_path, "LICENSE")))
  
  # 3. Check NEWS.md
  expect_true(file.exists(file.path(pkg_path, "NEWS.md")))
  
  # 4. Check README.md
  expect_true(file.exists(file.path(pkg_path, "README.md")))
  
  # 5. Generate and check documentation
  if (requireNamespace("roxygen2", quietly = TRUE)) {
    roxygen2::roxygenise(pkg_path)
    
    # Check NAMESPACE
    namespace_lines <- readLines(file.path(pkg_path, "NAMESPACE"))
    expect_true(any(grepl("export", namespace_lines)))
  }
  
  # 6. Run R CMD check
  if (requireNamespace("rcmdcheck", quietly = TRUE)) {
    check_results <- rcmdcheck::rcmdcheck(
      pkg_path,
      args = c("--no-manual", "--no-vignettes"),
      error_on = "never"
    )
    
    # Should have minimal errors/warnings for CRAN submission
    expect_equal(check_results$errors, 0)
  }
})

# -----------------------------------------------------------------------------
# AUTOMATION AND SCRIPTING TESTS
# -----------------------------------------------------------------------------

test_that("Automated testing scripts work correctly", {
  temp_dir <- tempfile()
  dir.create(temp_dir)
  on.exit(unlink(temp_dir, recursive = TRUE), add = TRUE)
  
  # Create automated test script
  test_script <- '
    #!/usr/bin/env Rscript
    
    # Automated testing script for R package
    
    args <- commandArgs(trailingOnly = TRUE)
    package_path <- if (length(args) > 0) args[1] else "."
    
    # Load required packages
    if (!requireNamespace("devtools", quietly = TRUE)) {
      install.packages("devtools")
    }
    if (!requireNamespace("rcmdcheck", quietly = TRUE)) {
      install.packages("rcmdcheck")
    }
    
    library(devtools)
    library(rcmdcheck)
    
    # Run tests
    cat("Running package tests...\\n")
    test_results <- devtools::test(package_path)
    
    # Run R CMD check
    cat("Running R CMD check...\\n")
    check_results <- rcmdcheck::rcmdcheck(package_path, error_on = "never")
    
    # Generate report
    cat("\\n=== TEST SUMMARY ===\\n")
    cat("Tests passed:", sum(test_results$passed), "\\n")
    cat("Tests failed:", sum(test_results$failed), "\\n")
    cat("Check errors:", check_results$errors, "\\n")
    cat("Check warnings:", check_results$warnings, "\\n")
    
    # Exit with appropriate code
    if (sum(test_results$failed) > 0 || check_results$errors > 0) {
      quit(status = 1)
    } else {
      quit(status = 0)
    }
  '
  
  script_path <- file.path(temp_dir, "run_tests.R")
  writeLines(test_script, script_path)
  
  # Make script executable (on Unix systems)
  if (.Platform$OS.type == "unix") {
    Sys.chmod(script_path, mode = "0755")
  }
  
  # Validate script
  expect_true(file.exists(script_path))
  
  script_content <- readLines(script_path)
  expect_true(any(grepl("library", script_content)))
  expect_true(any(grepl("test", script_content)))
  expect_true(any(grepl("check", script_content)))
  expect_true(any(grepl("quit", script_content)))
})

test_that("Release automation scripts work correctly", {
  temp_dir <- tempfile()
  dir.create(temp_dir)
  on.exit(unlink(temp_dir, recursive = TRUE), add = TRUE)
  
  # Create release automation script
  release_script <- '
    #!/usr/bin/env Rscript
    
    # Release automation script for R package
    
    args <- commandArgs(trailingOnly = TRUE)
    if (length(args) == 0) {
      stop("Usage: Rscript release.R <version_type>")
    }
    
    version_type <- args[1]
    valid_types <- c("patch", "minor", "major")
    
    if (!version_type %in% valid_types) {
      stop("Version type must be one of: ", paste(valid_types, collapse = ", "))
    }
    
    # Load required packages
    if (!requireNamespace("devtools", quietly = TRUE)) {
      install.packages("devtools")
    }
    if (!requireNamespace("usethis", quietly = TRUE)) {
      install.packages("usethis")
    }
    
    library(devtools)
    library(usethis)
    
    # Get current version
    current_version <- desc::desc_get_version()
    cat("Current version:", current_version, "\\n")
    
    # Calculate new version
    version_parts <- as.numeric(strsplit(current_version, "\\.")[[1]])
    
    if (version_type == "patch") {
      version_parts[3] <- version_parts[3] + 1
    } else if (version_type == "minor") {
      version_parts[2] <- version_parts[2] + 1
      version_parts[3] <- 0
    } else if (version_type == "major") {
      version_parts[1] <- version_parts[1] + 1
      version_parts[2] <- 0
      version_parts[3] <- 0
    }
    
    new_version <- paste(version_parts, collapse = ".")
    cat("New version will be:", new_version, "\\n")
    
    # Update version in DESCRIPTION
    usethis::use_version(new_version)
    
    # Run final checks
    cat("Running final checks...\\n")
    devtools::check()
    devtools::test()
    
    # Build package
    cat("Building package...\\n")
    build_path <- devtools::build()
    
    cat("Release preparation complete!\\n")
    cat("Package built at:", build_path, "\\n")
    cat("Next steps:\\n")
    cat("1. Review and commit changes\\n")
    cat("2. Create git tag:", paste0("v", new_version), "\\n")
    cat("3. Submit to CRAN or GitHub releases\\n")
  '
  
  script_path <- file.path(temp_dir, "release.R")
  writeLines(release_script, script_path)
  
  # Validate script
  expect_true(file.exists(script_path))
  
  script_content <- readLines(script_path)
  expect_true(any(grepl("version", script_content)))
  expect_true(any(grepl("check", script_content)))
  expect_true(any(grepl("build", script_content)))
  expect_true(any(grepl("Usage", script_content)))
})

# Print summary
cat("Workflow test suite created successfully!\n")
cat("Components included:\n")
cat("- Package building and validation tests\n")
cat("- CI/CD integration tests (GitHub Actions, Docker)\n")
cat("- Documentation generation tests (pkgdown, vignettes)\n")
cat("- Deployment and distribution tests\n")
cat("- CRAN submission requirement tests\n")
cat("- Automation and scripting tests\n")
cat("Total tests: ", testthat:::count_tests(), "\n")